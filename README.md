Мартыненко Владимир УИБО-14-24

**Определение:**

**Бинарный поиск (Binary Search)** — алгоритм поиска элемента в отсортированном массиве путем последовательного деления массива пополам и сравнения искомого элемента со средним элементом текущего диапазона.

**Анализ:**

**Инициализация границ поиска**:

**low_index = 0** - устанавливаем начальную границу поиска

**high_index = len(sequence) - 1** - устанавливаем конечную границу поиска

**len(sequence)** - получаем длину коллекции

**Основной цикл поиска**:

**while low_index <= high_index**: - продолжаем пока есть область для поиска

**Вычисление середины**:

**center_index = (low_index + high_index) >> 1** - вычисляем средний индекс


**Временная сложность:** **O(log n)**

**Почему O(log n)**: На каждой итерации область поиска уменьшается вдвое, количество итераций пропорционально log₂n.

---

**Определение:**

**Сортировка пузырьком (Bubble Sort)** — алгоритм многократно проходит по массиву, сравнивая и обменивая соседние элементы, пока массив не будет отсортирован.

**Анализ:**

**Инициализация размера**:

**total_elements = len(sequence)** - определяем размер коллекции

**Внешний цикл for pass_num in range(total_elements)**: выполняется total_elements раз

**Внутренний цикл for position in range(total_elements - pass_num - 1)**: проходит по неотсортированной части массива

**Оператор сравнения if sequence[position] > sequence[position + 1]**: сравнивает соседние элементы

**Оператор обмена sequence[position], sequence[position + 1] = sequence[position + 1], sequence[position]**: меняет местами элементы в неправильном порядке

**Временная сложность:** **O(n²)**

**Почему O(n²)**: Двойная вложенность циклов приводит к n*(n-1)/2 сравнениям в худшем случае.

---

**Определение:**

**Поиск Фибоначчи (Fibonacci Search)** — алгоритм поиска в отсортированном массиве с использованием чисел Фибоначчи для определения позиций сравнения.

**Анализ:**

**Инициализация чисел Фибоначчи**:

**fib_prev = 0** - инициализация F(k-2)

**fib_curr = 1** - инициализация F(k-1)

**fib_next = fib_prev + fib_curr** - вычисление F(k)

**Нахождение подходящего числа Фибоначчи**:

**while fib_next < length**: - пока число Фибоначчи меньше длины массива

**fib_prev = fib_curr** - сдвиг чисел Фибоначчи

**fib_curr = fib_next**

**fib_next = fib_prev + fib_curr**

**Основной цикл поиска**:

**while fib_next > 1**: - продолжаем пока есть элементы для проверки

**check_index = min(search_start + fib_prev, length - 1)** - вычисляем индекс для проверки

**Сравнение и обновление границ**:

**if sequence[check_index] < target_value**: - если элемент меньше искомого

**Обновление чисел Фибоначчи для правой части**

**search_start = check_index** - сдвиг начальной позиции

**elif sequence[check_index] > target_value**: - если элемент больше искомого

**Обновление чисел Фибоначчи для левой части**

**Временная сложность:** **O(log n)**

**Почему O(log n)**: Алгоритм уменьшает область поиска экспоненциально, используя числа Фибоначчи.

---

**Определение:**

**Сортировка вставками (Insertion Sort)** — алгоритм построения отсортированного массива путем последовательной вставки элементов на правильные позиции.

**Анализ:**

**Внешний цикл for current_index in range(1, len(collection))**: проходит по всем элементам начиная со второго

**current_element = collection[current_index]** - сохраняем текущий элемент для вставки

**Внутренний цикл while previous_index >= 0 and collection[previous_index] > current_element**: сдвигаем элементы большие текущего

**collection[previous_index + 1] = current_element** - вставляем элемент на правильную позицию

**Временная сложность:** **O(n²)**

**Почему O(n²)**: В худшем случае каждый элемент требует сравнения со всеми предыдущими элементами.

---

**Определение:**

**Сортировка слиянием (Merge Sort)** — алгоритм "разделяй и властвуй", рекурсивно делящий массив на части, сортирующий их и объединяющий обратно.

**Анализ:**

**Базовый случай if (arr.size() <= 1)** - массив из 0 или 1 элемента уже отсортирован

**Разделение массива**:

**size_t mid = arr.size() / 2** - находим середину

**vector<int> left(arr.begin(), arr.begin() + mid)** - левая половина

**vector<int> right(arr.begin() + mid, arr.end())** - правая половина

**Рекурсивная сортировка**:

**left = mergeSort(left)** - сортируем левую часть

**right = mergeSort(right)** - сортируем правую часть

**Слияние mergeVectors**:

**while (i < left.size() && j < right.size())** - пока есть элементы в обоих массивах

**if (left[i] < right[j])** - сравнение элементов

**result.push_back()** - добавление в результирующий массив

**Временная сложность:** **O(n log n)**

**Почему O(n log n)**: Рекурсивное деление дает log n уровней, на каждом уровне выполняется O(n) операций слияния.

---

**Определение:**

**Пирамидальная сортировка (Heap Sort)** — алгоритм, использующий структуру данных "куча" для сортировки элементов.

**Анализ:**

**Функция heapifySubtree**:

**int largestIndex = rootIndex** - предполагаем корень наибольшим

**int leftChildIndex = 2 * rootIndex + 1** - левый потомок

**int rightChildIndex = 2 * rootIndex + 2** - правый потомок

**Поиск наибольшего элемента**:

**leftChildIndex < heapSize && data[rootIndex] < data[leftChildIndex]** - проверка левого потомка

**rightChildIndex < heapSize && data[largestIndex] < data[rightChildIndex]** - проверка правого потомка

**Построение кучи**:

**for (int currentIndex = dataSize / 2 - 1; currentIndex >= 0; currentIndex--)** - построение max-heap

**Основной процесс сортировки**:

**swap(data[0], data[currentIndex])** - перемещение корня в конец

**heapifySubtree(data, currentIndex, 0)** - восстановление свойства кучи

**Временная сложность:** **O(n log n)**

**Почему O(n log n)**: Построение кучи O(n), каждый из n извлечений максимума O(log n).

---

**Определение:**

**Быстрая сортировка (Quick Sort)** — алгоритм "разделяй и властвуй", выбирающий опорный элемент и разделяющий массив на элементы меньше и больше опорного.

**Анализ:**

**Базовый случай if start_pos < end_pos:** - массив из более чем одного элемента

**Разбиение partition_collection**:

**pivot_value = collection[end_pos]** - выбор опорного элемента

**smaller_index = start_pos - 1** - индекс для элементов меньше опорного

**for current_index in range(start_pos, end_pos)**: - проход по элементам

**if collection[current_index] <= pivot_value:** - сравнение с опорным

**Рекурсивные вызовы**:

**sort_quick(collection, start_pos, split_index - 1)** - левая часть

**sort_quick(collection, split_index + 1, end_pos)** - правая часть

**Временная сложость:** **O(n log n)** в среднем, **O(n²)** в худшем случае

**Почему O(n log n)**: В среднем массив делится пополам на каждом уровне рекурсии.

---

**Определение:**

**Сортировка выбором (Selection Sort)** — алгоритм, находящий минимальный элемент на каждой итерации и помещающий его на текущую позицию.

**Анализ:**

**Внешний цикл for (int currentPosition = 0; currentPosition < elementCount; currentPosition++)**: проходит по всем позициям

**int minValueIndex = currentPosition** - предполагаем текущий элемент минимальным

**Внутренний цикл for (int searchIndex = currentPosition + 1; searchIndex < elementCount; searchIndex++)**: поиск минимального элемента

**if (data[searchIndex] < data[minValueIndex])** - сравнение с текущим минимумом

**minValueIndex = searchIndex** - обновление индекса минимума

**Обмен элементов** - помещение найденного минимума на текущую позицию

**Временная сложность:** **O(n²)**

**Почему O(n²)**: Для каждого из n элементов выполняется поиск минимума в оставшейся части O(n).

---

**Определение:**

**Последовательный поиск (Sequential Search)** — простейший алгоритм поиска, проверяющий каждый элемент массива последовательно.

**Анализ:**

**Основной цикл for (size_t index = 0; index < collection.size(); index++)**: проходит по всем элементам

**if (collection[index] == searchValue)** - сравнение текущего элемента с искомым

**return index** - возврат индекса при нахождении

**return -1** - возврат -1 если элемент не найден

**Временная сложность:** **O(n)**

**Почему O(n)**: В худшем случае требуется проверить все n элементов массива.

---

**Определение:**

**Сортировка Шелла (Shell Sort)** — алгоритм, сортирующий элементы на определенных расстояниях друг от друга, постепенно уменьшая это расстояние.

**Анализ:**

**Инициализация промежутка**:

**interval = total_elements // 2** - начальный интервал

**Основной цикл while interval > 0:** - пока интервал больше 0

**for current_index in range(interval, total_elements)**: - проход по элементам с текущим интервалом

**current_value = sequence[current_index]** - сохранение текущего элемента

**Сдвиг элементов while position >= interval and sequence[position - interval] > current_value:** - сдвиг элементов

**sequence[position] = current_value** - вставка элемента на правильную позицию

**interval //= 2** - уменьшение интервала

**Временная сложость:** **O(n²)** в худшем случае, **O(n log n)** в лучшем случае

**Почему O(n²)**: Зависит от выбранной последовательности интервалов.

---

**Определение:**

**Интерполяционный поиск (Interpolation Search)** — алгоритм поиска в отсортированном массиве, использующий интерполяцию для предсказания позиции искомого элемента.

**Анализ:**

**Вычисление позиции** - использование интерполяционной формулы для предсказания позиции

**Сравнение и сужение области поиска** - аналогично бинарному поиску, но с более точным предсказанием позиции

**Временная сложность:** **O(log log n)** в среднем, **O(n)** в худшем случае

**Почему O(log log n)**: При равномерном распределении данных область поиска уменьшается быстрее, чем в бинарном поиске.
